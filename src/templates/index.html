<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Paper Scissors Arena</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/retro.css') }}">
</head>
<body>
    <div class="container">
        <div class="header animate__animated animate__fadeInDown">
            <h1>Rock Paper Scissors Arena</h1>
            <div class="coins">
                <span class="coin-icon">ü™ô</span>
                <span id="coinBalance">100</span>
            </div>
            <div class="stats animate__animated animate__fadeInUp">
                <h3 class="stats-title">Your Stats</h3>
                <div class="stats-grid">
                    <div class="stats-item">
                        <span class="stats-label">Wins</span>
                        <span id="playerWins" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Losses</span>
                        <span id="playerLosses" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Draws</span>
                        <span id="playerDraws" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Total Won</span>
                        <span id="totalCoinsWon" class="stats-value">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen active">
            <div class="lobby-content animate__animated animate__fadeIn">
                <button id="createMatchBtn" class="btn glow-effect">
                    <span class="btn-icon">üéÆ</span>
                    Create Match
                </button>
                <div id="createMatchForm" class="animate__animated" style="display: none;">
                    <div class="stake-input-container">
                        <input type="number" id="stakeInput" placeholder="Enter stake amount" min="1" class="btn">
                        <div class="stake-preview">
                            <span class="coin-icon">ü™ô</span>
                            <span id="stakePreview">0</span>
                        </div>
                    </div>
                    <button id="confirmStakeBtn" class="btn glow-effect">
                        <span class="btn-icon">‚ú®</span>
                        Confirm Stake
                    </button>
                </div>
                <h2 class="section-title">Open Matches</h2>
                <div id="matchList" class="match-list">
                    <!-- Match items will be added here dynamically -->
                </div>
            </div>
        </div>

        <!-- Waiting Screen -->
        <div id="waitingScreen" class="screen">
            <div class="waiting-content animate__animated animate__fadeIn">
                <h2>Waiting for opponent...</h2>
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
                <div class="waiting-message">
                    <span class="message-text">Looking for worthy opponents</span>
                    <span class="dots">...</span>
                </div>
            </div>
        </div>

        <!-- Play Screen -->
        <div id="playScreen" class="screen">
            <div class="play-content animate__animated animate__fadeIn">
                <div class="timer-container">
                    <div class="timer" id="moveTimer">10</div>
                    <div class="timer-ring"></div>
                </div>
                <h2 class="battle-text animate__animated animate__pulse animate__infinite">Choose your move!</h2>
                <div class="move-buttons">
                    <button class="btn move-btn animate__animated animate__bounceIn" data-move="rock">
                        <span class="move-icon">‚úä</span>
                        <span class="move-text">Rock</span>
                        <div class="move-effect"></div>
                    </button>
                    <button class="btn move-btn animate__animated animate__bounceIn animate__delay-1s" data-move="paper">
                        <span class="move-icon">‚úã</span>
                        <span class="move-text">Paper</span>
                        <div class="move-effect"></div>
                    </button>
                    <button class="btn move-btn animate__animated animate__bounceIn animate__delay-2s" data-move="scissors">
                        <span class="move-icon">‚úåÔ∏è</span>
                        <span class="move-text">Scissors</span>
                        <div class="move-effect"></div>
                    </button>
                </div>
                <div id="moveStatus" class="status-container">
                    <div id="playerMoveStatus" class="status-message">Waiting for your move...</div>
                    <div id="opponentMoveStatus" class="status-message">Waiting for opponent to move...</div>
                </div>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="resultScreen" class="screen">
            <div class="result animate__animated animate__zoomIn">
                <h2 class="result-title">Match Result</h2>
                <div id="resultAnimation" class="result-animation"></div>
                <div id="movesDisplay" class="moves-container">
                    <div id="playerMove" class="move-display animate__animated"></div>
                    <div class="vs animate__animated animate__pulse animate__infinite">VS</div>
                    <div id="opponentMove" class="move-display animate__animated"></div>
                </div>
                <p id="resultText" class="result-message animate__animated"></p>
                <div class="match-stats animate__animated animate__fadeIn animate__delay-1s">
                    <h3>Match Statistics</h3>
                    <div id="matchStats" class="stats-grid"></div>
                </div>
                <div class="action-buttons animate__animated animate__fadeIn animate__delay-2s">
                    <div class="rematch-container">
                        <button id="rematchBtn" class="btn" style="display: none;">
                            <span class="btn-icon">üîÑ</span>
                            Rematch (<span id="rematchTimer">15</span>s)
                        </button>
                        <div id="rematchStatus" class="status-message"></div>
                    </div>
                    <button id="backToLobbyBtn" class="btn">
                        <span class="btn-icon">üè†</span>
                        Back to Lobby
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        // Global variables
        let currentMatchId = null;
        let moveTimer = null;
        let isCreator = false;
        let socket = null;
        let matches = {};  // Store match states
        let rematchTimer = null;
        let lastMatchStake = null;  // Store stake for rematch
        let lastCoinBalance = null; // Store last coin balance for animation

        // Initialize socket connection with logging
        socket = io({
            transports: ['websocket'],
            upgrade: false,
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });

        socket.on('connect', () => {
            console.log('Socket connected:', socket.id);
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
        });

        socket.on('disconnect', () => {
            console.log('Socket disconnected');
        });

        socket.on('reconnect', (attemptNumber) => {
            console.log('Socket reconnected after', attemptNumber, 'attempts');
            if (currentMatchId) {
                socket.emit('join_match_room', { match_id: currentMatchId });
            }
        });

        // Game state management
        async function updateGameState() {
            try {
                const response = await fetch('/api/state');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // Update coin balance and stats with animation
                const coinBalance = document.getElementById('coinBalance');
                const coinsContainer = document.querySelector('.coins');
                if (coinBalance && coinsContainer) {
                    const newBalance = data.coins;
                    if (lastCoinBalance !== null && newBalance !== lastCoinBalance) {
                        const difference = newBalance - lastCoinBalance;
                        const changeElement = document.createElement('div');
                        changeElement.className = `coin-change ${difference > 0 ? 'increase' : 'decrease'}`;
                        changeElement.textContent = `${difference > 0 ? '+' : ''}${difference}`;
                        coinsContainer.appendChild(changeElement);
                        setTimeout(() => changeElement.remove(), 1000);
                    }
                    lastCoinBalance = newBalance;
                    coinBalance.textContent = newBalance;
                }

                if (data.stats) {
                    const elements = {
                        'playerWins': data.stats.wins,
                        'playerLosses': data.stats.losses,
                        'playerDraws': data.stats.draws,
                        'totalCoinsWon': data.stats.total_coins_won
                    };

                    for (const [id, value] of Object.entries(elements)) {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        }
                    }
                }
                
                // Update match list
                const matchList = document.getElementById('matchList');
                if (matchList) {
                    matchList.innerHTML = '';
                    data.open_matches.forEach(match => {
                        const matchDiv = document.createElement('div');
                        matchDiv.className = 'match-item animate__animated animate__fadeIn';
                        matchDiv.innerHTML = `
                            <span>Stake: <span class="coin-icon">ü™ô</span>${match.stake}</span>
                            <button class="btn" onclick="joinMatch('${match.id}')">Join Match</button>
                        `;
                        matchList.appendChild(matchDiv);
                    });
                }

                // Handle current match state
                if (data.current_match) {
                    currentMatchId = data.current_match.id;
                    isCreator = data.current_match.is_creator;

                    // Show appropriate screen based on match status
                    if (data.current_match.status === 'waiting') {
                        if (!document.getElementById('waitingScreen').classList.contains('active')) {
                            showScreen('waitingScreen');
                        }
                    } else if (data.current_match.status === 'playing') {
                        if (!document.getElementById('playScreen').classList.contains('active') &&
                            !document.getElementById('resultScreen').classList.contains('active')) {
                            showScreen('playScreen');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating game state:', error);
            }
        }

        // Global functions
        function showScreen(screenId) {
            console.log('Showing screen:', screenId);
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
            } else {
                console.error('Screen not found:', screenId);
            }
        }

        function startMoveTimer() {
            let timeLeft = 10;
            const timerElement = document.getElementById('moveTimer');
            const timerRing = document.querySelector('.timer-ring');
            
            if (!timerElement || !timerRing) {
                console.error('Timer elements not found');
                return;
            }
            
            function updateTimer() {
                timerElement.textContent = timeLeft;
                timerRing.style.setProperty('--progress', (timeLeft / 10) * 100 + '%');
                
                if (timeLeft <= 3) {
                    timerElement.style.color = 'var(--danger-color)';
                    timerElement.classList.add('animate__animated', 'animate__headShake');
                }
                timeLeft--;
                
                if (timeLeft < 0) {
                    clearInterval(moveTimer);
                    timerElement.textContent = 'Time is up!';
                    timerElement.classList.remove('animate__headShake');
                    timerElement.classList.add('animate__bounceOut');
                    document.querySelectorAll('.move-btn').forEach(btn => {
                        btn.disabled = true;
                        btn.classList.add('animate__animated', 'animate__fadeOut');
                    });
                    
                    // Notify server about timeout
                    if (currentMatchId) {
                        socket.emit('move_timeout', { match_id: currentMatchId });
                    }
                }
            }
            
            // Clear any existing timer
            stopMoveTimer();
            
            // Reset timer elements
            timerElement.classList.remove('animate__headShake', 'animate__bounceOut');
            timerElement.style.color = 'var(--warning-color)';
            document.querySelectorAll('.move-btn').forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('animate__fadeOut');
            });
            
            updateTimer();
            moveTimer = setInterval(updateTimer, 1000);
        }

        function stopMoveTimer() {
            if (moveTimer) {
                clearInterval(moveTimer);
                moveTimer = null;
                const timerElement = document.getElementById('moveTimer');
                if (timerElement) {
                    timerElement.classList.remove('animate__headShake', 'animate__bounceOut');
                }
            }
        }

        function stopRematchTimer() {
            if (rematchTimer) {
                clearInterval(rematchTimer);
                rematchTimer = null;
                const rematchBtn = document.getElementById('rematchBtn');
                if (rematchBtn) {
                    rematchBtn.classList.remove('animate__headShake');
                    rematchBtn.style.color = '';
                }
            }
        }

        function getMoveIcon(move) {
            switch (move) {
                case 'rock': return '‚úä';
                case 'paper': return '‚úã';
                case 'scissors': return '‚úåÔ∏è';
                default: return '';
            }
        }

        // Match functions
        window.joinMatch = async function(matchId) {
            try {
                if (!socket || !socket.connected) {
                    throw new Error('Socket not connected');
                }

                console.log('Joining match:', matchId);
                const response = await fetch('/api/join_match', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({match_id: matchId}),
                    credentials: 'same-origin'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Join match response:', data);

                if (data.success) {
                    currentMatchId = matchId;
                    isCreator = false;
                    socket.emit('join_match_room', { match_id: matchId });
                    showScreen('playScreen');
                    startMoveTimer();
                } else {
                    console.error('Failed to join match:', data.message);
                }
            } catch (error) {
                console.error('Error joining match:', error);
            }
        };

        // Socket event handlers
        socket.on('match_result', (data) => {
            console.log('Match result event received:', data);
            stopMoveTimer();

            const isWinner = (data.winner === 'player1' && isCreator) ||
                           (data.winner === 'player2' && !isCreator);

            // Prepare move displays with animations
            const playerMoveElement = document.getElementById('playerMove');
            const opponentMoveElement = document.getElementById('opponentMove');

            if (playerMoveElement && opponentMoveElement) {
                const playerMove = isCreator ? data.creator_move : data.joiner_move;
                const opponentMove = isCreator ? data.joiner_move : data.creator_move;

                playerMoveElement.classList.add('animate__animated', 'animate__bounceIn');
                playerMoveElement.style.animationDelay = '0s';
                playerMoveElement.innerHTML = `
                    <span class="move-icon">${getMoveIcon(playerMove)}</span>
                    <span class="move-text">${playerMove}</span>
                `;

                opponentMoveElement.classList.add('animate__animated', 'animate__bounceIn');
                opponentMoveElement.style.animationDelay = '0.5s';
                opponentMoveElement.innerHTML = `
                    <span class="move-icon">${getMoveIcon(opponentMove)}</span>
                    <span class="move-text">${opponentMove}</span>
                `;
            }

            // Show result with enhanced animations
            setTimeout(() => {
                let resultText = '';
                const resultAnimation = document.getElementById('resultAnimation');
                const resultTextElement = document.getElementById('resultText');
                const resultContainer = document.querySelector('.result');

                if (resultAnimation && resultTextElement && resultContainer) {
                    resultContainer.classList.remove('win', 'lose', 'draw');
                    
                    if (data.winner === 'draw') {
                        resultText = "It's a draw!";
                        resultAnimation.innerHTML = 'ü§ù';
                        resultAnimation.classList.add('animate__animated', 'animate__bounce');
                        resultContainer.classList.add('draw');
                    } else if (isWinner) {
                        resultText = 'You won!';
                        resultAnimation.innerHTML = 'üèÜ';
                        resultAnimation.classList.add('animate__animated', 'animate__tada');
                        resultContainer.classList.add('win');
                        
                        // Add celebration particles
                        for (let i = 0; i < 20; i++) {
                            const particle = document.createElement('div');
                            particle.className = 'celebration-particle';
                            particle.style.left = Math.random() * 100 + '%';
                            particle.style.animationDelay = Math.random() * 0.5 + 's';
                            resultContainer.appendChild(particle);
                            setTimeout(() => particle.remove(), 2000);
                        }
                    } else {
                        resultText = 'You lost!';
                        resultAnimation.innerHTML = 'üíî';
                        resultAnimation.classList.add('animate__animated', 'animate__wobble');
                        resultContainer.classList.add('lose');
                    }

                    resultTextElement.textContent = resultText;
                    resultTextElement.classList.add('animate__animated', 'animate__fadeIn');

                    // Update match stats
                    const matchStats = document.getElementById('matchStats');
                    if (matchStats) {
                        matchStats.innerHTML = `
                            <div class="stats-item">
                                <span class="stats-label">Stake</span>
                                <span class="stats-value">ü™ô ${data.stake}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Result</span>
                                <span class="stats-value">${resultText}</span>
                            </div>
                        `;
                    }

                    // Show rematch button if applicable
                    const rematchBtn = document.getElementById('rematchBtn');
                    if (rematchBtn) {
                        rematchBtn.style.display = 'block';
                        startRematchTimer();
                    }
                }

                showScreen('resultScreen');
            }, 1000);
        });

        socket.on('match_joined', (data) => {
            console.log('Match joined event received:', data);
            showScreen('playScreen');
            startMoveTimer();
        });

        socket.on('match_cancelled', () => {
            console.log('Match cancelled');
            currentMatchId = null;
            showScreen('lobbyScreen');
            stopMoveTimer();
            stopRematchTimer();
        });

        socket.on('rematch_request', (data) => {
            console.log('Rematch request received:', data);
            const rematchStatus = document.getElementById('rematchStatus');
            if (rematchStatus) {
                rematchStatus.textContent = 'Opponent wants a rematch!';
                rematchStatus.classList.add('animate__animated', 'animate__pulse');
            }
        });

        socket.on('rematch_accepted', (data) => {
            console.log('Rematch accepted:', data);
            currentMatchId = data.match_id;
            showScreen('playScreen');
            startMoveTimer();
            const rematchStatus = document.getElementById('rematchStatus');
            if (rematchStatus) {
                rematchStatus.textContent = '';
                rematchStatus.classList.remove('animate__animated', 'animate__pulse');
            }
        });

        socket.on('rematch_declined', () => {
            console.log('Rematch declined');
            const rematchStatus = document.getElementById('rematchStatus');
            if (rematchStatus) {
                rematchStatus.textContent = 'Rematch declined';
                rematchStatus.classList.add('animate__animated', 'animate__fadeOut');
            }
        });

        // Event listeners
        document.getElementById('createMatchBtn').addEventListener('click', () => {
            const createMatchForm = document.getElementById('createMatchForm');
            if (createMatchForm) {
                createMatchForm.style.display = 'block';
                createMatchForm.classList.add('animate__fadeIn');
            }
        });

        document.getElementById('stakeInput').addEventListener('input', (event) => {
            const stakePreview = document.getElementById('stakePreview');
            if (stakePreview) {
                stakePreview.textContent = event.target.value;
            }
        });

        document.getElementById('confirmStakeBtn').addEventListener('click', async () => {
            const stakeInput = document.getElementById('stakeInput');
            const stake = parseInt(stakeInput.value);
            
            if (!stake || stake < 1) {
                console.error('Invalid stake amount');
                return;
            }

            try {
                const response = await fetch('/api/create_match', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({stake: stake}),
                    credentials: 'same-origin'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Create match response:', data);

                if (data.success) {
                    currentMatchId = data.match_id;
                    isCreator = true;
                    socket.emit('join_match_room', { match_id: data.match_id });
                    showScreen('waitingScreen');
                } else {
                    console.error('Failed to create match:', data.message);
                }
            } catch (error) {
                console.error('Error creating match:', error);
            }
        });

        document.querySelectorAll('.move-btn').forEach(button => {
            button.addEventListener('click', async () => {
                if (!currentMatchId) {
                    console.error('No active match');
                    return;
                }

                const move = button.getAttribute('data-move');
                if (!move) {
                    console.error('No move specified');
                    return;
                }

                try {
                    const response = await fetch('/api/make_move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({
                            match_id: currentMatchId,
                            move: move
                        }),
                        credentials: 'same-origin'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('Make move response:', data);

                    if (data.success) {
                        document.querySelectorAll('.move-btn').forEach(btn => {
                            btn.disabled = true;
                            btn.classList.add('animate__animated', 'animate__fadeOut');
                        });
                        
                        const playerMoveStatus = document.getElementById('playerMoveStatus');
                        if (playerMoveStatus) {
                            playerMoveStatus.textContent = `You chose ${move}`;
                            playerMoveStatus.classList.add('animate__animated', 'animate__fadeIn');
                        }
                    } else {
                        console.error('Failed to make move:', data.message);
                    }
                } catch (error) {
                    console.error('Error making move:', error);
                }
            });
        });

        document.getElementById('backToLobbyBtn').addEventListener('click', () => {
            currentMatchId = null;
            showScreen('lobbyScreen');
            stopMoveTimer();
            stopRematchTimer();
        });

        document.getElementById('rematchBtn').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/request_rematch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({match_id: currentMatchId}),
                    credentials: 'same-origin'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Request rematch response:', data);

                if (data.success) {
                    const rematchStatus = document.getElementById('rematchStatus');
                    if (rematchStatus) {
                        rematchStatus.textContent = 'Rematch requested...';
                        rematchStatus.classList.add('animate__animated', 'animate__pulse');
                    }
                } else {
                    console.error('Failed to request rematch:', data.message);
                }
            } catch (error) {
                console.error('Error requesting rematch:', error);
            }
        });

        // Initial state update
        updateGameState();
        setInterval(updateGameState, 5000);  // Update every 5 seconds
    </script>
</body>
</html>