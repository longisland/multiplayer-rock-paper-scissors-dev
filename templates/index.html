<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Paper Scissors Arena</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/retro.css') }}">
</head>
<body>
    <div class="container">
        <div class="header animate__animated animate__fadeInDown">
            <h1>Rock Paper Scissors Arena</h1>
            <div class="coins">
                <span class="coin-icon">ü™ô</span>
                <span id="coinBalance">100</span>
            </div>
            <div class="stats animate__animated animate__fadeInUp">
                <h3 class="stats-title">Your Stats</h3>
                <div class="stats-grid">
                    <div class="stats-item">
                        <span class="stats-label">Wins</span>
                        <span id="playerWins" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Losses</span>
                        <span id="playerLosses" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Draws</span>
                        <span id="playerDraws" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Total Won</span>
                        <span id="totalCoinsWon" class="stats-value">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen active">
            <div class="lobby-content animate__animated animate__fadeIn">
                <button id="createMatchBtn" class="btn glow-effect">
                    <span class="btn-icon">üéÆ</span>
                    Create Match
                </button>
                <div id="createMatchForm" class="animate__animated" style="display: none;">
                    <div class="stake-input-container">
                        <input type="number" id="stakeInput" placeholder="Enter stake amount" min="1" class="btn">
                        <div class="stake-preview">
                            <span class="coin-icon">ü™ô</span>
                            <span id="stakePreview">0</span>
                        </div>
                    </div>
                    <button id="confirmStakeBtn" class="btn glow-effect">
                        <span class="btn-icon">‚ú®</span>
                        Confirm Stake
                    </button>
                </div>
                <h2 class="section-title">Open Matches</h2>
                <div id="matchList" class="match-list">
                    <!-- Match items will be added here dynamically -->
                </div>
            </div>
        </div>

        <!-- Waiting Screen -->
        <div id="waitingScreen" class="screen">
            <div class="waiting-content animate__animated animate__fadeIn">
                <h2>Waiting for opponent...</h2>
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
                <div class="waiting-message">
                    <span class="message-text">Looking for worthy opponents</span>
                    <span class="dots">...</span>
                </div>
            </div>
        </div>

        <!-- Play Screen -->
        <div id="playScreen" class="screen">
            <div class="play-content animate__animated animate__fadeIn">
                <div class="timer-container">
                    <div class="timer" id="moveTimer">10</div>
                    <div class="timer-ring"></div>
                </div>
                <h2 class="battle-text animate__animated animate__pulse animate__infinite">Choose your move!</h2>
                <div class="move-buttons">
                    <button class="btn move-btn animate__animated animate__bounceIn" data-move="rock">
                        <span class="move-icon">‚úä</span>
                        <span class="move-text">Rock</span>
                        <div class="move-effect"></div>
                    </button>
                    <button class="btn move-btn animate__animated animate__bounceIn animate__delay-1s" data-move="paper">
                        <span class="move-icon">‚úã</span>
                        <span class="move-text">Paper</span>
                        <div class="move-effect"></div>
                    </button>
                    <button class="btn move-btn animate__animated animate__bounceIn animate__delay-2s" data-move="scissors">
                        <span class="move-icon">‚úåÔ∏è</span>
                        <span class="move-text">Scissors</span>
                        <div class="move-effect"></div>
                    </button>
                </div>
                <div id="moveStatus" class="status-container">
                    <div id="playerMoveStatus" class="status-message">Waiting for your move...</div>
                    <div id="opponentMoveStatus" class="status-message">Waiting for opponent to move...</div>
                </div>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="resultScreen" class="screen">
            <div class="result animate__animated animate__zoomIn">
                <h2 class="result-title">Match Result</h2>
                <div id="resultAnimation" class="result-animation"></div>
                <div id="movesDisplay" class="moves-container">
                    <div id="playerMove" class="move-display animate__animated"></div>
                    <div class="vs animate__animated animate__pulse animate__infinite">VS</div>
                    <div id="opponentMove" class="move-display animate__animated"></div>
                </div>
                <p id="resultText" class="result-message animate__animated"></p>
                <div class="match-stats animate__animated animate__fadeIn animate__delay-1s">
                    <h3>Match Statistics</h3>
                    <div id="matchStats" class="stats-grid"></div>
                </div>
                <div class="action-buttons animate__animated animate__fadeIn animate__delay-2s">
                    <div class="rematch-container">
                        <button id="rematchBtn" class="btn" style="display: none;">
                            <span class="btn-icon">üîÑ</span>
                            Rematch (<span id="rematchTimer">15</span>s)
                        </button>
                        <div id="rematchStatus" class="status-message"></div>
                    </div>
                    <button id="backToLobbyBtn" class="btn">
                        <span class="btn-icon">üè†</span>
                        Back to Lobby
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        // Global variables
        let currentMatchId = null;
        let moveTimer = null;
        let isCreator = false;
        let socket = null;
        let matches = {};  // Store match states
        let rematchTimer = null;
        let lastMatchStake = null;  // Store stake for rematch
        let hasRequestedRematch = false;  // Track if player has requested rematch

        // Initialize socket connection with logging
        socket = io({
            transports: ['websocket'],
            upgrade: false,
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });

        socket.on('connect', () => {
            console.log('Socket connected:', socket.id);
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
        });

        socket.on('disconnect', () => {
            console.log('Socket disconnected');
        });

        socket.on('reconnect', (attemptNumber) => {
            console.log('Socket reconnected after', attemptNumber, 'attempts');
            if (currentMatchId) {
                socket.emit('join_match_room', { match_id: currentMatchId });
            }
        });

        // Game state management
        async function updateGameState() {
            try {
                const response = await fetch('/api/state');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // Update coin balance and stats
                const coinBalance = document.getElementById('coinBalance');
                if (coinBalance) {
                    coinBalance.textContent = data.coins;
                }

                if (data.stats) {
                    const elements = {
                        'playerWins': data.stats.wins,
                        'playerLosses': data.stats.losses,
                        'playerDraws': data.stats.draws,
                        'totalCoinsWon': data.stats.total_coins_won
                    };

                    for (const [id, value] of Object.entries(elements)) {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        }
                    }
                }
                
                // Update match list
                const matchList = document.getElementById('matchList');
                if (matchList) {
                    matchList.innerHTML = '';
                    data.open_matches.forEach(match => {
                        const matchDiv = document.createElement('div');
                        matchDiv.className = 'match-item animate__animated animate__fadeIn';
                        matchDiv.innerHTML = `
                            <span>Stake: <span class="coin-icon">ü™ô</span>${match.stake}</span>
                            <button class="btn" onclick="joinMatch('${match.id}')">Join Match</button>
                        `;
                        matchList.appendChild(matchDiv);
                    });
                }

                // Handle current match state
                if (data.current_match) {
                    currentMatchId = data.current_match.id;
                    isCreator = data.current_match.is_creator;

                    // Show appropriate screen based on match status
                    if (data.current_match.status === 'waiting') {
                        if (!document.getElementById('waitingScreen').classList.contains('active')) {
                            showScreen('waitingScreen');
                        }
                    } else if (data.current_match.status === 'playing') {
                        if (!document.getElementById('playScreen').classList.contains('active') &&
                            !document.getElementById('resultScreen').classList.contains('active')) {
                            showScreen('playScreen');
                            startMoveTimer();
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating game state:', error);
            }
        }

        // Global functions
        function showScreen(screenId) {
            console.log('Showing screen:', screenId);
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
            } else {
                console.error('Screen not found:', screenId);
            }
        }

        function startMoveTimer() {
            let timeLeft = 10;
            const timerElement = document.getElementById('moveTimer');
            const timerRing = document.querySelector('.timer-ring');
            
            if (!timerElement || !timerRing) {
                console.error('Timer elements not found');
                return;
            }
            
            function updateTimer() {
                timerElement.textContent = timeLeft;
                timerRing.style.setProperty('--progress', (timeLeft / 10) * 100 + '%');
                
                if (timeLeft <= 3) {
                    timerElement.style.color = 'var(--danger-color)';
                    timerElement.classList.add('animate__animated', 'animate__headShake');
                }
                timeLeft--;
                
                if (timeLeft < 0) {
                    clearInterval(moveTimer);
                    timerElement.textContent = 'Time is up!';
                    timerElement.classList.remove('animate__headShake');
                    timerElement.classList.add('animate__bounceOut');
                    document.querySelectorAll('.move-btn').forEach(btn => {
                        btn.disabled = true;
                        btn.classList.add('animate__animated', 'animate__fadeOut');
                    });
                }
            }
            
            // Clear any existing timer
            stopMoveTimer();
            
            // Reset timer elements
            timerElement.classList.remove('animate__headShake', 'animate__bounceOut');
            timerElement.style.color = 'var(--warning-color)';
            document.querySelectorAll('.move-btn').forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('animate__fadeOut');
            });
            
            updateTimer();
            moveTimer = setInterval(updateTimer, 1000);
        }

        function stopMoveTimer() {
            if (moveTimer) {
                clearInterval(moveTimer);
                moveTimer = null;
                const timerElement = document.getElementById('moveTimer');
                if (timerElement) {
                    timerElement.classList.remove('animate__headShake', 'animate__bounceOut');
                }
            }
        }

        function stopRematchTimer() {
            if (rematchTimer) {
                clearInterval(rematchTimer);
                rematchTimer = null;
                const rematchBtn = document.getElementById('rematchBtn');
                if (rematchBtn) {
                    rematchBtn.classList.remove('animate__headShake');
                    rematchBtn.style.color = '';
                }
            }
        }

        function getMoveIcon(move) {
            switch (move) {
                case 'rock': return '‚úä';
                case 'paper': return '‚úã';
                case 'scissors': return '‚úåÔ∏è';
                default: return '';
            }
        }

        // Match functions
        window.joinMatch = async function(matchId) {
            try {
                if (!socket || !socket.connected) {
                    throw new Error('Socket not connected');
                }

                console.log('Joining match:', matchId);
                const response = await fetch('/api/join_match', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({match_id: matchId}),
                    credentials: 'same-origin'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                if (data.success) {
                    currentMatchId = matchId;
                    isCreator = false;
                    socket.emit('join_match_room', { match_id: matchId });
                    showScreen('playScreen');
                    startMoveTimer();
                }
            } catch (error) {
                console.error('Error joining match:', error);
                alert(error.message || 'Error joining match');
            }
        };

        // Socket event handlers
        socket.on('match_started', (data) => {
            console.log('Match started:', data);
            currentMatchId = data.match_id;
            isCreator = data.creator_id === socket.id;
            
            // If this is a rematch, show a message
            if (data.rematch) {
                const rematchStatus = document.getElementById('rematchStatus');
                if (rematchStatus) {
                    rematchStatus.textContent = 'Rematch starting...';
                    setTimeout(() => {
                        rematchStatus.textContent = '';
                    }, 2000);
                }
            }
            
            showScreen('playScreen');
            startMoveTimer();
        });

        socket.on('move_made', (data) => {
            console.log('Move made:', data);
            const isPlayerMove = (isCreator && data.player === 'creator') || (!isCreator && data.player === 'joiner');
            const statusElement = document.getElementById(isPlayerMove ? 'playerMoveStatus' : 'opponentMoveStatus');
            
            if (statusElement) {
                statusElement.textContent = data.auto ? 
                    (isPlayerMove ? 'Random move assigned!' : 'Opponent\'s random move assigned!') :
                    (isPlayerMove ? 'You made your move!' : 'Opponent made their move!');
                statusElement.classList.add('animate__animated', 'animate__bounceIn');
            }
        });

        socket.on('match_result', (data) => {
            console.log('Match result:', data);
            stopMoveTimer();
            showScreen('resultScreen');
            
            const playerMove = isCreator ? data.creator_move : data.joiner_move;
            const opponentMove = isCreator ? data.joiner_move : data.creator_move;
            
            // Display moves
            document.getElementById('playerMove').innerHTML = `
                <div class="move-icon">${getMoveIcon(playerMove)}</div>
                <div class="move-label">Your Move</div>
            `;
            document.getElementById('opponentMove').innerHTML = `
                <div class="move-icon">${getMoveIcon(opponentMove)}</div>
                <div class="move-label">Opponent's Move</div>
            `;
            
            // Determine and display result
            const isWinner = data.winner_id === socket.id;
            const isDraw = !data.winner_id;
            
            const resultText = document.getElementById('resultText');
            if (resultText) {
                resultText.textContent = isDraw ? 'It\'s a Draw!' : (isWinner ? 'You Won!' : 'You Lost!');
                resultText.className = `result-message animate__animated ${
                    isDraw ? 'draw' : (isWinner ? 'win' : 'loss')
                } animate__bounceIn`;
            }
            
            // Display match stats
            const matchStats = document.getElementById('matchStats');
            if (matchStats) {
                matchStats.innerHTML = `
                    <div class="stats-item">
                        <span class="stats-label">Stake</span>
                        <span class="stats-value"><span class="coin-icon">ü™ô</span>${data.stake}</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Result</span>
                        <span class="stats-value ${isDraw ? 'draw' : (isWinner ? 'win' : 'loss')}">
                            ${isDraw ? 'Draw' : (isWinner ? 'Win' : 'Loss')}
                        </span>
                    </div>
                `;
            }
            
            // Handle rematch
            hasRequestedRematch = false;  // Reset rematch request state
            const rematchBtn = document.getElementById('rematchBtn');
            const rematchStatus = document.getElementById('rematchStatus');
            const rematchTimerDisplay = document.getElementById('rematchTimer');
            
            // Reset rematch button state
            rematchBtn.disabled = false;
            rematchBtn.classList.remove('animate__pulse', 'animate__infinite');
            rematchBtn.innerHTML = `
                <span class="btn-icon">üîÑ</span>
                Rematch (<span id="rematchTimer">15</span>s)
            `;
            
            // Only show rematch button if player has enough coins
            if (data.can_rematch) {
                rematchBtn.style.display = 'block';
                
                // Clear any existing timer
                stopRematchTimer();
                
                // Start rematch timer
                let timeLeft = 15;
                function updateTimer() {
                    const timerDisplay = document.getElementById('rematchTimer');
                    if (timerDisplay) {
                        timerDisplay.textContent = timeLeft;
                    }
                    
                    if (timeLeft <= 5 && rematchBtn && !rematchBtn.disabled) {
                        rematchBtn.classList.add('animate__headShake');
                        rematchBtn.style.color = 'var(--danger-color)';
                    }
                    
                    timeLeft--;
                    
                    if (timeLeft < 0) {
                        clearInterval(rematchTimer);
                        if (rematchBtn) {
                            rematchBtn.classList.remove('animate__headShake');
                            rematchBtn.style.display = 'none';
                        }
                        if (rematchStatus) {
                            rematchStatus.textContent = 'Rematch time expired';
                            rematchStatus.classList.add('animate__animated', 'animate__fadeOut');
                            setTimeout(() => {
                                rematchStatus.textContent = '';
                                rematchStatus.classList.remove('animate__fadeOut');
                            }, 3000);
                        }
                        if (!hasRequestedRematch) {
                            socket.emit('rematch_declined', { match_id: currentMatchId });
                        }
                    }
                }
                
                rematchTimer = setInterval(updateTimer, 1000);
                
                // Handle rematch button click
                rematchBtn.onclick = () => {
                    hasRequestedRematch = true;
                    socket.emit('rematch_request', { match_id: currentMatchId });
                    rematchBtn.disabled = true;
                    rematchBtn.innerHTML = `
                        <span class="btn-icon">üîÑ</span>
                        Waiting for opponent...
                    `;
                    if (rematchStatus) {
                        rematchStatus.textContent = 'Waiting for opponent to accept rematch...';
                    }
                };
            } else {
                if (rematchStatus) {
                    rematchStatus.textContent = 'Not enough coins for rematch';
                }
            }
            
            // Handle rematch events
            socket.on('rematch_accepted_by_player', (data) => {
                console.log('Player accepted rematch:', data);
                const rematchStatus = document.getElementById('rematchStatus');
                const rematchBtn = document.getElementById('rematchBtn');
                
                if (rematchStatus) {
                    if (data.player_type === (isCreator ? 'joiner' : 'creator')) {
                        rematchStatus.textContent = 'Opponent wants a rematch! Accept?';
                        if (rematchBtn && !rematchBtn.disabled) {
                            rematchBtn.classList.add('animate__animated', 'animate__pulse', 'animate__infinite');
                        }
                    } else {
                        rematchStatus.textContent = 'Waiting for opponent to accept rematch...';
                        if (rematchBtn) {
                            rematchBtn.disabled = true;
                            rematchBtn.classList.remove('animate__pulse', 'animate__infinite');
                        }
                    }
                }
            });
            
            socket.on('rematch_declined', (data) => {
                console.log('Opponent declined rematch:', data);
                const rematchBtn = document.getElementById('rematchBtn');
                const rematchStatus = document.getElementById('rematchStatus');
                
                stopRematchTimer();
                
                if (rematchBtn) {
                    rematchBtn.style.display = 'none';
                    rematchBtn.disabled = false;
                    rematchBtn.classList.remove('animate__pulse', 'animate__infinite');
                }
                
                if (rematchStatus) {
                    rematchStatus.textContent = data.reason === 'insufficient_coins' ? 
                        'Not enough coins for rematch' : 'Opponent declined rematch';
                    rematchStatus.classList.add('animate__animated', 'animate__fadeOut');
                    setTimeout(() => {
                        rematchStatus.textContent = '';
                        rematchStatus.classList.remove('animate__fadeOut');
                    }, 3000);
                }
            });
            
            socket.on('rematch_started', (data) => {
                console.log('Rematch started:', data);
                currentMatchId = data.match_id;
                isCreator = data.creator_id === socket.id;
                
                // Stop rematch timer
                stopRematchTimer();
                
                // Clear rematch UI
                const rematchBtn = document.getElementById('rematchBtn');
                const rematchStatus = document.getElementById('rematchStatus');
                if (rematchBtn) {
                    rematchBtn.style.display = 'none';
                    rematchBtn.disabled = false;
                    rematchBtn.classList.remove('animate__pulse', 'animate__infinite');
                }
                if (rematchStatus) {
                    rematchStatus.textContent = '';
                }
                
                // Show play screen
                showScreen('playScreen');
                startMoveTimer();
            });
        });

        // Initialize game state
        updateGameState();
        setInterval(updateGameState, 5000);  // Update every 5 seconds
    </script>
</body>
</html>